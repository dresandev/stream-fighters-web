---
interface Props {
  targetDate: string
}

const { targetDate } = Astro.props
---

<div class="wrapper">
  <canvas id="countdown" data-target-date={targetDate} class="countdown"></canvas>
  <div class="labels">
    <div class="label-wrapper">
      <span class="label">DÃ­as</span>
    </div>
    <div class="label-wrapper">
      <span class="label">Horas</span>
    </div>
    <div class="label-wrapper">
      <span class="label">Minutos</span>
    </div>
    <div class="label-wrapper">
      <span class="label">Segundos</span>
    </div>
  </div>
</div>

<script>
  const canvas = document.querySelector<HTMLCanvasElement>("#countdown")!
  const ctx = canvas.getContext("2d")!
  const targetDateAttr = canvas.dataset.targetDate

  if (!targetDateAttr) {
    throw new Error("Target date is required")
  }

  const targetDate = new Date(targetDateAttr).getTime()
  let lastTimeStr = ""

  let cellSize: number
  let cellGap: number
  let digitGap: number
  const digitWidth = 5
  const digitHeight = 7

  const digits = {
    "0": ["01110", "10001", "10011", "10101", "11001", "10001", "01110"],
    "1": ["00100", "01100", "00100", "00100", "00100", "00100", "01110"],
    "2": ["01110", "10001", "00001", "00010", "00100", "01000", "11111"],
    "3": ["01110", "10001", "00001", "00110", "00001", "10001", "01110"],
    "4": ["00110", "01010", "10010", "11111", "00010", "00010", "00010"],
    "5": ["11111", "10000", "11110", "00001", "00001", "10001", "01110"],
    "6": ["01110", "10001", "10000", "11110", "10001", "10001", "01110"],
    "7": ["11111", "00001", "00010", "00100", "00100", "00100", "00100"],
    "8": ["01110", "10001", "10001", "01110", "10001", "10001", "01110"],
    "9": ["01110", "10001", "10001", "01111", "00001", "10001", "01110"],
    ":": ["00000", "00000", "00100", "00000", "00100", "00000", "00000"],
  }

  const MS_PER_SECOND = 1000
  const MS_PER_MINUTE = MS_PER_SECOND * 60
  const MS_PER_HOUR = MS_PER_MINUTE * 60
  const MS_PER_DAY = MS_PER_HOUR * 24

  let digitCache: Record<string, HTMLCanvasElement> = {}

  const breakpoints = [
    { min: 800, cellSize: 8, cellGap: 4, digitGap: 6, w: 716, h: 80 },
    { min: 600, cellSize: 6, cellGap: 2.5, digitGap: 6, w: 525, h: 57 },
    { min: 480, cellSize: 4.5, cellGap: 2, digitGap: 6, w: 416, h: 44 },
    { min: 0, cellSize: 3.8, cellGap: 1.5, digitGap: 3, w: 320, h: 36 },
  ]

  function applyResponsiveSizes() {
    const width = window.innerWidth
    const config = breakpoints.find((bp) => width >= bp.min)!
    cellSize = config.cellSize
    cellGap = config.cellGap
    digitGap = config.digitGap
    canvas.width = config.w
    canvas.height = config.h

    buildDigitCache()
  }

  function buildDigitCache() {
    digitCache = {}
    for (let key in digits) {
      const pattern = digits[key as keyof typeof digits]
      const w = digitWidth * (cellSize + cellGap)
      const h = digitHeight * (cellSize + cellGap)
      const offscreen = document.createElement("canvas")
      offscreen.width = w
      offscreen.height = h
      const offCtx = offscreen.getContext("2d")!

      for (let row = 0; row < digitHeight; row++) {
        for (let col = 0; col < digitWidth; col++) {
          const px = col * (cellSize + cellGap)
          const py = row * (cellSize + cellGap)
          offCtx.fillStyle = pattern[row][col] === "1" ? "#fff" : "#222"
          offCtx.fillRect(px, py, cellSize, cellSize)
        }
      }
      digitCache[key] = offscreen
    }
  }

  function drawTime(timeStr: string) {
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    const charWidth = digitWidth * (cellSize + cellGap) + digitGap
    let offsetX = 0
    for (let char of timeStr) {
      ctx.drawImage(digitCache[char], offsetX, 0)
      offsetX += charWidth
    }
  }

  function updateCountdown() {
    const now = Date.now()
    let diff = targetDate - now
    if (diff <= 0) diff = 0

    const days = Math.floor(diff / MS_PER_DAY)
    const hours = Math.floor((diff % MS_PER_DAY) / MS_PER_HOUR)
    const minutes = Math.floor((diff % MS_PER_HOUR) / MS_PER_MINUTE)
    const seconds = Math.floor((diff % MS_PER_MINUTE) / MS_PER_SECOND)

    const timeStr =
      String(days).padStart(2, "0") +
      ":" +
      String(hours).padStart(2, "0") +
      ":" +
      String(minutes).padStart(2, "0") +
      ":" +
      String(seconds).padStart(2, "0")

    if (timeStr !== lastTimeStr) {
      drawTime(timeStr)
      lastTimeStr = timeStr
    }
  }

  function loop() {
    updateCountdown()
    requestAnimationFrame(loop)
  }

  window.addEventListener("resize", () => {
    applyResponsiveSizes()
    lastTimeStr = ""
  })

  applyResponsiveSizes()
  loop()
</script>

<style>
  .countdown {
    image-rendering: pixelated;
  }

  .wrapper {
    inline-size: fit-content;
    margin-inline: auto;
  }

  .labels {
    display: flex;
    justify-content: space-between;
    padding-block-start: 4px;
    block-size: 1lh;
  }

  .label-wrapper {
    --size: 122px;
    inline-size: var(--size);
    position: relative;
  }

  .label {
    position: absolute;
    inset-inline-start: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    font-weight: 500;
    text-transform: uppercase;
  }

  @media screen and (max-width: 800px) {
    .label-wrapper {
      --size: 89px;
    }
  }

  @media screen and (max-width: 600px) {
    .label-wrapper {
      --size: 70px;
    }

    .label {
      font-size: 12px;
    }
  }

  @media screen and (max-width: 480px) {
    .label-wrapper {
      --size: 54px;
    }
  }
</style>
